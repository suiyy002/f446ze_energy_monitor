#include "fft.h"
#include "main.h"
#include "stm32f4xx_hal.h"
#include "arm_math.h"
#include "nrf24l01.h"
#include "nrf24l01_reg.h"


#define FFT_LENGTH  128   //1024  4096   //FFT 长度，默认是 1024 点 FFT

float fft_inputbuf[FFT_LENGTH * 2]; //FFT 输入数组
float fft_harmonicA_output[FFT_LENGTH]; //FFT 输出数组
float fft_harmonicB_output[FFT_LENGTH]; //FFT 输出数组
float fft_harmonicC_output[FFT_LENGTH]; //FFT 输出数组

//arm_cfft_radix4_instance_f32 scfft;
arm_cfft_radix2_instance_f32 scfft2;


/*
uint16_t testdta[256]={0x7FFF,0x8323,0x8647,0x896A,0x8C8B,0x8FAA,0x92C7,0x95E1,0x98F8,0x9C0A,0x9F19,0xA223,0xA527,0xA826,0xAB1E,0xAE10
,0xB0FB,0xB3DE,0xB6B9,0xB98C,0xBC55,0xBF16,0xC1CD,0xC47A,0xC71C,0xC9B3,0xCC3F,0xCEBF,0xD132,0xD39A,0xD5F4,0xD842
,0xDA81,0xDCB3,0xDED6,0xE0EB,0xE2F1,0xE4E7,0xE6CE,0xE8A5,0xEA6C,0xEC23,0xEDC9,0xEF5E,0xF0E1,0xF254,0xF3B4,0xF503
,0xF640,0xF76B,0xF883,0xF989,0xFA7C,0xFB5C,0xFC28,0xFCE2,0xFD89,0xFE1C,0xFE9C,0xFF08,0xFF61,0xFFA6,0xFFD7,0xFFF5
,0xFFFE,0xFFF5,0xFFD7,0xFFA6,0xFF61,0xFF08,0xFE9C,0xFE1C,0xFD89,0xFCE2,0xFC29,0xFB5C,0xFA7C,0xF989,0xF883,0xF76B
,0xF640,0xF503,0xF3B4,0xF254,0xF0E1,0xEF5E,0xEDC9,0xEC23,0xEA6C,0xE8A5,0xE6CE,0xE4E7,0xE2F1,0xE0EB,0xDED6,0xDCB3
,0xDA81,0xD842,0xD5F4,0xD39A,0xD132,0xCEBF,0xCC3F,0xC9B3,0xC71C,0xC47A,0xC1CD,0xBF16,0xBC55,0xB98C,0xB6B9,0xB3DE
,0xB0FB,0xAE10,0xAB1E,0xA826,0xA527,0xA222,0x9F19,0x9C0A,0x98F8,0x95E1,0x92C7,0x8FAA,0x8C8B,0x8969,0x8647,0x8323
,0x7FFF,0x7CDB,0x79B7,0x7694,0x7373,0x7054,0x6D37,0x6A1D,0x6706,0x63F4,0x60E5,0x5DDB,0x5AD7,0x57D8,0x54E0,0x51EE
,0x4F03,0x4C20,0x4945,0x4672,0x43A8,0x40E8,0x3E31,0x3B84,0x38E2,0x364B,0x33BF,0x313F,0x2ECB,0x2C64,0x2A0A,0x27BC
,0x257D,0x234B,0x2128,0x1F13,0x1D0D,0x1B17,0x1930,0x1759,0x1592,0x13DB,0x1235,0x10A0,0x0F1D,0x0DAA,0x0C49,0x0AFB
,0x09BE,0x0893,0x077B,0x0675,0x0582,0x04A2,0x03D5,0x031C,0x0275,0x01E2,0x0162,0x00F6,0x009D,0x0058,0x0027,0x0009
,0x0000,0x0009,0x0027,0x0058,0x009D,0x00F6,0x0162,0x01E2,0x0275,0x031C,0x03D6,0x04A3,0x0583,0x0675,0x077B,0x0893
,0x09BE,0x0AFB,0x0C4A,0x0DAA,0x0F1D,0x10A1,0x1236,0x13DB,0x1592,0x1759,0x1930,0x1B17,0x1D0E,0x1F13,0x2128,0x234B
,0x257D,0x27BD,0x2A0A,0x2C64,0x2ECC,0x3140,0x33C0,0x364B,0x38E3,0x3B85,0x3E31,0x40E8,0x43A9,0x4673,0x4945,0x4C21
,0x4F04,0x51EE,0x54E0,0x57D9,0x5AD7,0x5DDC,0x60E5,0x63F4,0x6707,0x6A1D,0x6D37,0x7054,0x7374,0x7695,0x79B8,0x7CDB};
*/




/*
void Get_FFT_DATA(uint16_t *p)//傅里叶变换后得到的是信号峰值和频率
{

 arm_cfft_radix2_init_f32(&scfft2,FFT_LENGTH,0,1);

  for(uint16_t i=0;i<FFT_LENGTH;i++)//生成信号序列
  {
  fft_inputbuf[2*i+1]=(float)*(p+i)/FFT_LENGTH;//testdta[i]/FFT_LENGTH;
  fft_inputbuf[2*i]=0;//虚部全部为 0：虚部在偶数位
  }

  arm_cfft_radix2_f32(&scfft2,fft_inputbuf); //FFT 计算（基 2）
  arm_cmplx_mag_f32(fft_inputbuf,fft_outputbuf,FFT_LENGTH);//把运算结果复数求模得幅值
  
  
}*/





void Harmonic_calculation_FFT(uint16_t *p, uint8_t id_)    //谐波计算
{
    uint16_t i = 0;
    // double FFT_adder = 0;
    // uint16_t lklk=0;
    // uint8_t  Tttt_buf[32]={0x1f,0x01};

    arm_cfft_radix2_init_f32(&scfft2, FFT_LENGTH, 0, 1);


    for (i = 0; i < FFT_LENGTH; i++)//生成信号序列
    {
        //fft_inputbuf[2*i]=100+
        //10*arm_sin_f32(2*PI*i/FFT_LENGTH)+
        //30*arm_sin_f32(2*PI*i*4/FFT_LENGTH)+
        //50*arm_cos_f32(2*PI*i*8/FFT_LENGTH);//*/
        //生成输入信号实部:实部在奇数位
        fft_inputbuf[2 * i + 1] = (float) (*(p + i)) / FFT_LENGTH;//testdta[i]/FFT_LENGTH;

        fft_inputbuf[2 * i] = 0.00000;//虚部全部为 0：虚部在偶数位
    }

    arm_cfft_radix2_f32(&scfft2, fft_inputbuf); //FFT 计算（基 2）

    if (0x0A == id_) {
        arm_cmplx_mag_f32(fft_inputbuf, fft_harmonicA_output, FFT_LENGTH);
        // for (i = 1; i < 51; i++) { FFT_adder += fft_harmonicA_output[i]; }
        // for (i = 1; i < 51; i++) { fft_harmonicA_output[i] /= FFT_adder; }

    }//把运算结果复数求模得幅值
    else if (0x0B == id_) {
        arm_cmplx_mag_f32(fft_inputbuf, fft_harmonicB_output, FFT_LENGTH);
        // for (i = 1; i < 51; i++) { FFT_adder += fft_harmonicB_output[i]; }
        // for (i = 1; i < 51; i++) { fft_harmonicB_output[i] /= FFT_adder; }

    }//把运算结果复数求模得幅值
    else if (0x0C == id_) {
        arm_cmplx_mag_f32(fft_inputbuf, fft_harmonicC_output, FFT_LENGTH);
        // for (i = 1; i < 51; i++) { FFT_adder += fft_harmonicC_output[i]; }
        // for (i = 1; i < 51; i++) { fft_harmonicC_output[i] /= FFT_adder; }
    }//把运算结果复数求模得幅值


    /*
    for(uint8_t k=0;k<210;k++)
    {for(uint8_t j=1;j<16;j++)
    {lklk=AD_03_data[k*15+j];
      Tttt_buf[j*2-1]=(lklk>>8)&0xff;
      Tttt_buf[j*2]=(lklk)&0xff;
    }
    SPI_Write_Buf(WR_TX_PLOAD, Tttt_buf, 32,0);
      HAL_Delay(1);
    CLearinterr(0);
    }*/
    //  HAL_Delay(1);

}













